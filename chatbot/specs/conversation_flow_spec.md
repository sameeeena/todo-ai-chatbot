# Conversation Flow Specification: Stateless AI Chatbot

This document outlines the execution lifecycle of a single interaction with the `TodoChatAgent`. The system is designed around a **stateless server architecture**, ensuring every request is independent and fully context-aware.

---

## 1. Request Lifecycle (Step-by-Step)

Each time a user sends a message, the following sequence occurs:

1.  **Receive User Message:** The server receives an HTTP POST request containing the `user_message`, `session_id`, and `user_id`.
2.  **Fetch Conversation History:** The server queries the database (e.g., SQLite/PostgreSQL) for all previous messages associated with the `session_id`.
3.  **Append New User Message:** The `user_message` is appended to the retrieved history to form the full prompt context.
4.  **Store User Message:** The new user message is persisted to the database immediately to ensure it isn't lost if the AI generation fails.
5.  **Run AI Agent:** The full history (including the new message) is sent to the AI Model (via OpenAI Agents SDK). The agent evaluates the intent against the `TodoChatAgent` instructions.
6.  **Invoke MCP Tools:** 
    - If the agent decides a task operation is needed, it triggers one or more **MCP Tools** (e.g., `list_tasks`, `add_task`).
    - The server executes these tools, retrieves the results, and feeds them back to the agent for a final natural language response.
7.  **Store Assistant Response:** The final response generated by the AI is stored in the database under the same `session_id`.
8.  **Return Response to Client:** The server sends the assistant's message back to the frontend to be displayed in the UI.

---

## 2. Why the Server Remains Stateless

In this architecture, "Stateless" means the application server does not retain any "in-memory" knowledge of the conversation between requests. 

- **State is Externalized:** All "memory" (conversation history) and "data" (tasks) reside in the database and MCP-managed storage.
- **Context Reconstruction:** Every request provides enough information (`session_id`) for the server to reconstruct the exact state needed to process the current turn.

---

## 3. Benefits of Statelessness

### A. Horizontal Scalability
Since any server instance can handle any request for any user (as long as it has DB access), we can spin up multiple instances behind a load balancer without worrying about "sticky sessions" or session synchronization.

### B. Resilience & Fault Tolerance
If a server process crashes or is restarted during a conversation, the user's experience is unaffected. The next request will simply hit a healthy instance, fetch the history from the DB, and continue exactly where it left off.

### C. Reduced Memory Overhead
The server doesn't need to maintain thousands of active socket connections or large memory buffers for every "online" user. Memory is only consumed during the active processing of a request.

### D. Simplified Deployment
Stateless servers make CI/CD easier. We can perform "Blue-Green" or "Rolling" deployments at any time, as there is no local state that needs to be migrated or drained before a server is taken offline.
